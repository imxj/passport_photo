<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>DIY Passport Photos</title>
    <style>
        /* CSS Styles */

        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
        }

        h1 {
            margin-bottom: 20px;
        }

        #camera-container {
            position: relative;
            display: inline-block;
            width: 640px;
            height: 480px;
            margin-bottom: 20px;
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
        }

        #video,
        #output-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
            object-fit: cover;
        }

        #capture-btn,
        #generate-grid-btn,
        #download-btn {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #photo-output,
        #print-grid {
            display: none;
        }
    </style>
    <!-- MediaPipe Selfie Segmentation -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>

<body>
    <h1>DYI Passport Photos</h1>
    <div id="camera-container">
        <video id="video" autoplay playsinline></video>
        <canvas id="output-canvas"></canvas>
    </div>
    <br>
    <button id="capture-btn">Capture Photo</button>
    <canvas id="photo-output"></canvas>
    <br><br>
    <button id="generate-grid-btn">Generate Print Grid</button>
    <button id="download-btn">Download Print Grid</button>
    <canvas id="print-grid"></canvas>

    <!-- Add the following lines -->
    <div id="instructions"
        style="margin-top: 30px; max-width: 600px; margin-left: auto; margin-right: auto; text-align: left; background-color: #f8f8f8; padding: 20px; border-radius: 5px;">
        <h3 style="margin-top: 0; color: #333;">Printing Instructions:</h3>
        <ol style="color: #555; line-height: 1.6;">
            <li>Download the generated photo grid image.</li>
            <li>Print the image at a local photo center (e.g., CVS, Walgreens) or using a high-quality home printer.
            </li>
            <li>Ensure the print settings maintain the original image size and quality.</li>
            <li>Once printed, carefully cut out individual passport photos along the grid lines.</li>
            <li>Double-check that the cut photos meet the required passport photo dimensions.</li>
        </ol>
        <p style="color: #666; font-style: italic; margin-top: 15px;">Note: The quality of your passport photos depends
            on your camera and printing method. For best results, we recommend using a professional printing service.
        </p>
    </div>

    <p id="privacy-notice" style="margin-top: 20px; font-size: 14px; color: #666;">
        Privacy Notice: We do not save or upload your captured photos.
        All processing is done locally in your browser.
    </p>

    <script>
        const video = document.getElementById('video');
        const outputCanvas = document.getElementById('output-canvas');
        const outputCtx = outputCanvas.getContext('2d');
        const captureBtn = document.getElementById('capture-btn');
        const photoOutput = document.getElementById('photo-output');
        const photoCtx = photoOutput.getContext('2d');
        const generateGridBtn = document.getElementById('generate-grid-btn');
        const printGrid = document.getElementById('print-grid');
        const printCtx = printGrid.getContext('2d');
        const downloadBtn = document.getElementById('download-btn');
        const cameraContainer = document.getElementById('camera-container');

        // Initialize MediaPipe Selfie Segmentation
        const selfieSegmentation = new SelfieSegmentation({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
            }
        });

        selfieSegmentation.setOptions({
            modelSelection: 1, // 0 for general, 1 for landscape (selfie)
        });

        selfieSegmentation.onResults(onResults);

        async function onResults(results) {
            // Draw the segmentation mask on the output canvas
            outputCtx.save();
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);

            // Only proceed if segmentation mask is available
            if (results.segmentationMask) {
                // Draw the video frame
                outputCtx.drawImage(
                    results.image,
                    0,
                    0,
                    outputCanvas.width,
                    outputCanvas.height
                );

                // Set composite mode to 'destination-in' to keep only the foreground
                outputCtx.globalCompositeOperation = 'destination-in';
                outputCtx.drawImage(
                    results.segmentationMask,
                    0,
                    0,
                    outputCanvas.width,
                    outputCanvas.height
                );

                // Change composite mode to 'destination-over' to place background behind the foreground
                outputCtx.globalCompositeOperation = 'destination-over';
                outputCtx.fillStyle = '#FFFFFF'; // Background color (white)
                outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
            }
            outputCtx.restore();
        }

        // Start video and processing
        async function startVideo() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.onloadedmetadata = async () => {
                video.play();
                outputCanvas.width = video.videoWidth;
                outputCanvas.height = video.videoHeight;
                // Start processing frames
                await sendFrame();

            };
        }
        // Draw the guide overlay
        function drawGuide() {
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);

            // Set the style for the guide (e.g., semi-transparent rectangle)
            outputCtx.strokeStyle = 'rgba(0, 255, 0, 0.8)'; // Green color with some transparency
            outputCtx.lineWidth = 4;

            // Draw an oval to indicate head position
            const centerX = outputCanvas.width / 2;
            const centerY = outputCanvas.height / 2 - 60;
            const radiusX = outputCanvas.width / 4; // Adjust as needed
            const radiusY = outputCanvas.height / 3; // Adjust as needed

            outputCtx.beginPath();
            outputCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            outputCtx.stroke();

            // Optional: Add horizontal line to indicate eye level
            outputCtx.beginPath();
            outputCtx.moveTo(centerX - radiusX / 2, centerY);
            outputCtx.lineTo(centerX + radiusX / 2, centerY);
            outputCtx.stroke();
        }

        async function sendFrame() {
            await selfieSegmentation.send({ image: video });
            requestAnimationFrame(sendFrame);
        }

        startVideo();

        // Capture the photo
        captureBtn.addEventListener('click', () => {
            photoOutput.width = outputCanvas.width;
            photoOutput.height = outputCanvas.height;
            photoCtx.drawImage(outputCanvas, 0, 0, photoOutput.width, photoOutput.height);
            cropToPassportSize();
            photoOutput.style.display = 'block';
        });

        function cropToPassportSize() {
            const dpi = 300;
            const inchToPixel = dpi;
            const cropWidth = 2 * inchToPixel;
            const cropHeight = 2 * inchToPixel;
            // width >= height
            let sx = (photoOutput.width - photoOutput.height) / 2;
            let sy = 0;

            // Create a temporary canvas for the cropped image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cropWidth;
            tempCanvas.height = cropHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // // Draw the cropped portion onto the temporary canvas
            // tempCtx.drawImage(
            //     photoOutput,
            //     sx, sourceY, adjustedCropHeight, adjustedCropHeight,
            //     0, -Math.min(sy, 0), cropWidth, cropWidth
            // );
            // Draw the cropped portion onto the temporary canvas
            tempCtx.drawImage(
                photoOutput,
                sx, sy, photoOutput.height, photoOutput.height,
                0, 0, cropWidth, cropWidth
            );

            // Resize the photoOutput canvas to 600x600
            photoOutput.width = cropWidth;
            photoOutput.height = cropHeight;

            // Draw the cropped and resized image onto the photoOutput canvas
            photoCtx.drawImage(tempCanvas, 0, 0, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
        }

        // Generate the print grid
        generateGridBtn.addEventListener('click', () => {
            const dpi = 300;
            const inchToPixel = dpi;
            const photoSize = 2 * inchToPixel;
            const margin = 0.25 * inchToPixel; // 0.25 inch margin

            const printWidthInches = 5;
            const printHeightInches = 7;

            const printWidth = printWidthInches * inchToPixel;
            const printHeight = printHeightInches * inchToPixel;

            printGrid.width = printWidth;
            printGrid.height = printHeight;

            const photosPerRow = Math.floor((printWidth - margin) / (photoSize + margin));
            const photosPerColumn = Math.floor((printHeight - margin) / (photoSize + margin));

            const totalWidthUsed = photosPerRow * photoSize + (photosPerRow - 1) * margin;
            const totalHeightUsed = photosPerColumn * photoSize + (photosPerColumn - 1) * margin;
            const leftMargin = (printWidth - totalWidthUsed) / 2;
            const topMargin = (printHeight - totalHeightUsed) / 2;

            printCtx.fillStyle = 'white';
            printCtx.fillRect(0, 0, printWidth, printHeight);

            // Draw photos and lines around them
            printCtx.strokeStyle = '#e0e0e0'; // Light gray color
            printCtx.lineWidth = 1;

            for (let i = 0; i < photosPerColumn; i++) {
                for (let j = 0; j < photosPerRow; j++) {
                    const x = leftMargin + j * (photoSize + margin);
                    const y = topMargin + i * (photoSize + margin);

                    // Draw the photo
                    printCtx.drawImage(
                        photoOutput,
                        x,
                        y,
                        photoSize,
                        photoSize
                    );

                    // Draw light thin lines around the photo
                    printCtx.strokeRect(x, y, photoSize, photoSize);
                }
            }

            printGrid.style.display = 'block';
            downloadBtn.style.display = 'inline-block';
        });

        // Download the print grid
        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'passport_photos.png';
            link.href = printGrid.toDataURL();
            link.click();
        });
    </script>
</body>

</html>